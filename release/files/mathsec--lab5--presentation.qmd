---
title: "Лабораторная работа №5"
subtitle: "Вычисление наибольшего общего делителя"
author:
  - name: Каймакджыоглу Мерич Дорук
    email: 1032245391@pfur.ru
    affiliation:
      - name: Российский университет дружбы народов
        city: Москва
license: "CC BY"
date: 2025-11-02
---

# Информация

## Докладчик

:::::::::::::: {.columns align=center}
::: {.column width="70%"}

* **Каймакджыоглу Мерич Дорук**
* Студент, кафедра Математического моделирования и искусственного интеллекта (ММиИИ)
* Российский университет дружбы народов
* [1032245391@pfur.ru](mailto:1032245391@pfur.ru)
* <https://github.com/dorukme123>

:::
::: {.column width="30%"}
:::
::::::::::::::

# Вводная часть

## Актуальность

-   Вероятностные тесты простоты являются фундаментальным инструментом в современной криптографии.
-   Асимметричные криптосистемы, такие как **RSA**, требуют генерации очень больших простых чисел ( $p$ и $q$).
-   Детерминированная проверка на простоту для чисел такого размера вычислительно невозможна.
-   Быстрые вероятностные тесты (Ферма, Миллера-Рабина) — это единственный практически применимый метод для **генерации ключей RSA**, что делает их критически важными для информационной безопасности.

## Объект и предмет исследования

-   **Объект:** Вероятностные алгоритмы в вычислительной теории чисел, применяемые в криптографии.
-   **Предмет:** Тест Ферма, тест Соловэя-Штрассена и тест Миллера-Рабина для проверки чисел на простоту.

## Цели и задачи

-   **Цель:** Изучить и программно реализовать три основных вероятностных алгоритма для проверки чисел на простоту.
-   **Задачи:**
    -   Реализовать тест Ферма, основанный на Малой теореме Ферма.
    -   Реализовать алгоритм вычисления символа Якоби.
    -   Реализовать тест Соловэя-Штрассена, основанный на критерии Эйлера.
    -   Реализовать тест Миллера-Рабина, являющийся промышленным стандартом.
    -   Продемонстрировать работу алгоритмов на примерах.

## Материалы и методы

-   **Язык программирования:** Python (с использованием модульной структуры).
-   **Алгоритмы:** Тест Ферма, Алгоритм Якоби, Тест Соловэя-Штрассена, Тест Миллера-Рабина.
-   **Математический аппарат:** Модульная арифметика, Малая теорема Ферма, критерий Эйлера, символ Якоби, свойства нетривиальных корней из 1.

# Теоретические сведения & Реализация

## Ключевые алгоритмы

-   **1. Тест Ферма:**
    -   **Принцип:** $a^{p-1}\equiv1(mod~p)$.
    -   **Проблема:** Простой, но существуют составные "числа Кармайкла", которые проходят этот тест.

-   **2. Тест Соловэя-Штрассена:**
    -   **Принцип:** $a^{\frac{n-1}{2}}\equiv(\frac{a}{n})(mod~n)$.
    -   **Преимущество:** Более надежен, чем тест Ферма; нет аналогов числам Кармайкла. Требует вычисления символа Якоби $(\frac{a}{n})$.

-   **3. Тест Миллера-Рабина:**
    -   **Принцип:** Представляет $n-1=2^{s}r$ и проверяет последовательность $a^r, a^{2r}, ..., a^{2^{s-1}r} \pmod{n}$.
    -   **Преимущество:** Самый надежный из трех. Если $n$ — составное, тест обнаружит это с вероятностью $\ge 3/4$ за одну итерацию. Является промышленным стандартом.

## Демонстрация

1. Алгоритм, реализующий тест Ферма (`fermat_test.py`)
```python
import random

def fermat_test_single(n: int) -> str:
    a = random.randint(2,n-2)
    r = pow(a, n - 1, n)

    if r == 1:
        return "probably prime"
    else:
        return "composite"
    
def run_feramn_test(n: int, t: int) -> str:
    if n < 5:
        return "input must be bigger than or = 5"
    if n % 2 == 0:
        return "composite even"
    
    for _ in range(t):
        if fermat_test_single(n) == "composite":
            return "composite"
    return "probably prime"

```

2. Алгоритм вычисления символа Якоби (jacobi_symbol.py)
```python
def jacoby_symbol(a: int, n: int) -> int:
    if n < 3 or n % 2 == 0:
        raise ValueError("must be odd integer")
    a = a % n
    g = 1

    while a != 0:
        if a == 1:
            return g
        k = 0
        a1 = a
        while a1 % 2 == 0 and a1 > 0:
            a1 //= 2
            k += 1
        
        s = 1
        if k % 2 != 0:
            n_mod_8 = n % 8
            if n_mod_8 == 3 or n_mod_8 == 5:
                s = -1
        
        if a1 == 1:
            return g * s
        
        if (n % 4) == 3 and (a1 % 4) == 3:
            s = -s
        
        a = n % a1
        g = g * s
    
    return 0
```

3. Алгоритм, реализующий тест Соловэя-Штрассена (solovay_strassen_test.py)
```python
import random
from jacobi_test import jacoby_symbol

def solovay_strassen_test_single(n: int) -> str:
    a = random.randint(2, n - 2)
    r = pow(a, (n - 1) // 2, n)
    
    if r != 1 and r != n - 1:
        return "composite"
    s = jacoby_symbol(a, n)

    if r == (s + n) % n:
        return "probably prime"
    else:
        return "composite"

def run_solovay_strassen_test(n: int, t: int) -> str:
    if n < 5:
        return "input must be bigger than or = 5"
    if n % 2 == 0:
        return "composite even"
    
    for _ in range(t):
        if solovay_strassen_test_single(n) == "composite":
            return "composite"
    return "probably prime"
```

4. Алгоритм, реализующий тест Миллера-Рабина (miller_rabin_test.py)
```python
import random

def miller_rabin_test_single(n: int) -> str:
    s = 0
    r = n -1
    while r % 2 == 0:
        s += 1
        r //= 2

    a = random.randint(2, n - 2)
    y = pow(a, r, n)

    if y != 1 and y != n - 1:
        j = 1
        while j <= s - 1 and y != n - 1:
            y = pow(y, 2, n)
            if y == 1:
                return "composite"
            j += 1
        if y != n - 1:
            return "composite"
    return "probably prime"

def run_miller_rabin_test(n: int, t: int) -> str:
    if n < 5:
        return "input must be bigger than or = 5"
    if n % 2 == 0:
        return "composite even"
    
    for _ in range(t):
        if miller_rabin_test_single(n) == "composite":
            return "composite"
    return "probably prime"
```

5. Главный файл и демонстрация работы (lab05_primality_tests.py)
```python
from fermat_test import run_feramn_test
from sol_stra_test import run_solovay_strassen_test
from mill_rab_test import run_miller_rabin_test

if __name__ == "__main__":
    try: 
        n_input = input("enter n: ")
        n = int(n_input)
        t_input = input ("enter t: ")
        t = int(t_input)

        if n < 5 or n % 2 == 0:
            print(f"Ошибка: {n} должно быть нечетным целым числом >= 5.")
            if n == 2 or n == 3:
                print(f"{n} - простое число.")
            elif n % 2 == 0:
                print(f"{n} - составное число (четное).")
        elif t < 1:
            print("Ошибка: количество итераций t должно быть >= 1.")
        else:
            print(f"\n--- Тестирование числа {n} (c {t} итерациями) ---")

            result_fermat = run_feramn_test(n, t)
            print(f"1. Тест Ферма: \t\t{result_fermat}")

            result_ss = run_solovay_strassen_test(n, t)
            print(f"2. Тест Соловэя-Штрассена: \t{result_ss}")

            result_mr = run_miller_rabin_test(n, t)
            print(f"3. Тест Миллера-Рабина: \t{result_mr}")

            print("\n--- Вывод ---")
            if result_mr == "probably prime":
                print(f"Число {n}, вероятно, простое.")
                print(f"(Вероятность ошибки < 1 / (4^{t}))") 
            else:
                print(f"Число {n} - составное.")
    except ValueError:
        print("Ошибка: Пожалуйста, введите корректные целые числа.")
    except Exception as e:
        print(f"Произошла ошибка: {e}")
```

## Выводы
Задачи выполнены: Все три вероятностных теста (Ферма, Соловэя-Штрассена, Миллера-Рабина) и алгоритм вычисления символа Якоби были успешно реализованы на Python.

Ключевой вывод: Практическая демонстрация (на 561) подтвердила теоретическую слабость теста Ферма и показала надежность тестов Соловэя-Штрассена и Миллера-Рабина.

Навыки: Получен практический опыт реализации фундаментальных алгоритмов, лежащих в основе генерации ключей для современных асимметричных криптосистем.