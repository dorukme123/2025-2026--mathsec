---
title: "Лабораторная работа №4"
subtitle: "Вычисление наибольшего общего делителя"
author:
  - name: Каймакджыоглу Мерич Дорук
    email: 1032245391@pfur.ru
    affiliation:
      - name: Российский университет дружбы народов
        city: Москва
license: "CC BY"
date: 2025-10-25
---

# Информация

## Докладчик

:::::::::::::: {.columns align=center}
::: {.column width="70%"}

* **Каймакджыоглу Мерич Дорук**
* Студент, кафедра Математического моделирования и искусственного интеллекта (ММиИИ)
* Российский университет дружбы народов
* [1032245391@pfur.ru](mailto:1032245391@pfur.ru)
* <https://github.com/dorukme123>

:::
::: {.column width="30%"}
:::
::::::::::::::

# Вводная часть

## Актуальность

-   Алгоритмы вычисления НОД являются фундаментальными в вычислительной теории чисел и криптографии.
-   **Расширенный алгоритм Евклида**  — это не просто теоретическое упражнение; это основной промышленный инструмент для нахождения **модульных обратных элементов**.
-   Без этого алгоритма невозможно было бы вычисление закрытого ключа $d$ в криптосистеме **RSA** (где $d \equiv e^{-1} \pmod{\phi(N)}$).
-   Бинарные алгоритмы демонстрируют, как теоретико-числовые задачи оптимизируются для реальных аппаратных реализаций.

## Объект и предмет исследования

-   **Объект:** Алгоритмы вычислительной теории чисел, применяемые в криптографии.
-   **Предмет:** Алгоритм Евклида, бинарный алгоритм Евклида, расширенный алгоритм Евклида  и расширенный бинарный алгоритм Евклида для вычисления НОД.

## Цели и задачи

-   **Цель:** Изучить и программно реализовать четыре различных алгоритма для нахождения НОД. 
-   **Задачи:**
    -   Реализовать классический алгоритм Евклида, основанный на делении с остатком.
    -   Реализовать бинарный алгоритм, использующий сдвиги и вычитания.
    -   Реализовать расширенный алгоритм Евклида для нахождения коэффициентов Безу $(x, y)$.
    -   Проверить корректность работы всех реализованных функций.

## Материалы и методы

-   **Язык программирования:** Python.
-   **Алгоритмы:** Четыре алгоритма НОД, описанные в методических указаниях.
-   **Математический аппарат:** Теория чисел, деление с остатком, тождество Безу (линейное представление НОД).

# Теоретические сведения & Реализация

## Ключевые алгоритмы

-   **1. Алгоритм Евклида:**
    -   **Принцип:** $\text{НОД}(a, b) = \text{НОД}(b, a \mod b)$.
    -   **Завершение:** Когда $r = 0$, предыдущий $r$ является НОД.

-   **2. Бинарный алгоритм Евклида:**
    -   **Принцип:** Использует свойства четности.
    -   $\text{НОД}(a, b) = 2 \cdot \text{НОД}(a/2, b/2)$ 
    -   $\text{НОД}(a, b) = \text{НОД}(a-b, b)$ 
    -   **Преимущество:** Заменяет дорогое деление (%) на быстрый сдвиг (>>) и вычитание. 

-   **3. Расширенный алгоритм Евклида:**
    -   **Цель:** Найти $d, x, y$, для которых $ax + by = d$.
    -   **Метод:** Поддерживает $x_i$ и $y_i$ на каждом шаге $i$, выражая остаток $r_i$ как линейную комбинацию $a$ и $b$. 

## Демонстрация

1. Классический алгоритм Евклида
```python
def euclidean_gcd(a, b):
    r_prev, r_curr = a, b
    # prev = a, curr = b

    while r_curr != 0:
        r_next = r_prev % r_curr
        r_prev = r_curr
        r_curr = r_next
    
    d = r_prev
    
    return d

vala = 12345
valb = [24690, 54321, 12541]
for val in valb:
    print(f"GCD({vala}, {val}) = {euclidean_gcd(vala, val)}")
```

2. Бинарный алгоритм Евклида
```python
def binaru_gcd(a, b):
    g = 1

    while a % 2 == 0 and b % 2 == 0:
        a //= 2
        b //= 2
        g *= 2
    
    u, v = a, b

    while u != 0:
        while u % 2 == 0:
            u //= 2
        while v % 2 == 0:
            v //= 2
        if u >= v:
            u = u - v
        else:
            v = v - u

    d = g * v

    return d

vala = 12345
valb = [24690, 54321, 12541]
for val in valb:
    print(f"GCD({vala}, {val}) = {binaru_gcd(vala, val)}")
```

3. Расширенный алгоритм Евклида
```python
# test = 91, 105, 154 == 7

def ext_euc_gcd(a, b):
    r_prev, r_curr = a, b
    x_prev, x_curr = 1, 0
    y_prev, y_curr = 0, 1

    while r_curr != 0:
        q = r_prev // r_curr
        r_next = r_prev % r_curr

        x_next = x_prev - q * x_curr
        y_next = y_prev - q * y_curr

        r_prev, r_curr = r_curr, r_next
        x_prev, x_curr = x_curr, x_next
        y_prev, y_curr = y_curr, y_next
    
    d, x, y = r_prev, x_prev, y_prev

    return d, x, y

d1, x1, y1 = ext_euc_gcd(105, 91)
d2, x2, y2 = ext_euc_gcd(154, d1)
print(f"GDC(105, 91) = {d1, x1, y1}")
print(f"final GDC(154, 7) = {d2, x2, y2}")
```

4. Расширенный бинарный алгоритм Евклида
```python
def ext_bin_gcd(a, b):
    g = 1
    while a % 2 == 0 and b % 2 == 0:
        a //= 2
        b //= 2
        g *= 2
    
    u, v = a, b
    A, B = 1, 0
    C, D = 0, 1

    while u != 0:
        while u % 2 == 0:
            u //= 2
            if A % 2 == 0 and B % 2 == 0:
                A //= 2
                B //= 2
            else:
                A = (A + b) // 2
                B = (B - a) // 2
            print("v: " + str(v))

        while v % 2 == 0:
            v //= 2
            if C % 2 == 0 and D % 2 == 0:
                C //= 2
                D //= 2
            else:
                C = (C + b) // 2
                D = (D - a) // 2
            print("u: " + str(u))

        if  u >= v:
            u = u - v
            A = A - C
            B = B - D
        else:
            v = v - u
            C = C - A
            D = D - B
    d = g * v
    x = C
    y = D
    return d, x, y

dbin, xbin, ybin = ext_bin_gcd(105, 91)
print(f"GCD(105, 91) = {dbin, xbin, ybin}")
```
## Выводы
- Задачи выполнены: Все четыре алгоритма НОД были успешно реализованы на Python в соответствии с заданием.
- Навыки: Получен практический опыт реализации фундаментальных алгоритмов теории чисел, лежащих в основе современной криптографии.